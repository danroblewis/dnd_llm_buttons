from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage, ToolMessage
from typing import TypedDict, Type, Callable, List, Any
import json
from typing import Literal
import asyncio
import signal
from contextlib import contextmanager

"""
Can I have the types dynamically generated by another LLM?
"""

@contextmanager
def timeout_context(seconds):
    """Context manager for timeout handling."""
    def timeout_handler(signum, frame):
        raise TimeoutError(f"Operation timed out after {seconds} seconds")
    
    # Set up signal handler for timeout
    old_handler = signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(seconds)
    
    try:
        yield
    finally:
        # Restore original signal handler and cancel alarm
        signal.alarm(0)
        signal.signal(signal.SIGALRM, old_handler)

class Structuralizer:
    def __init__(self, struct_type: Type, system_prompt: str, temperature: float = 0.7, base_url: str = "http://cluster:32605/v1", model: str = "gemma3:4b", timeout_seconds: int = 30):
        self.llm = ChatOpenAI(
            base_url=base_url,
            model=model,
            temperature=temperature,
            max_tokens=1000,
            max_retries=3,
            request_timeout=1000,
        )
        self.struct_type = struct_type
        self.system_prompt = system_prompt
        self.messages = [SystemMessage(content=self.system_prompt)]
        self.current_state = self.struct_type()
        self.timeout_seconds = timeout_seconds

    def add_message(self, message: str):
        self.messages.append(message)

    def notice(self, message: str):
        self.add_message(message)
        self.generate_struct()

    def generate_struct(self):
        """
        Generate a new state based on the current state and message we have `notice`d.
        """
        # Add current state as context
        state_prompt = self.get_state_prompt()
        prompt = SystemMessage(content=f"Current state:\n{state_prompt}\n\nPlease update these fields based on any new information in the conversation. Only change values that are directly mentioned or clearly implied by the new messages.")
        msgs = [*self.messages, prompt]
        
        try:
            with timeout_context(self.timeout_seconds):
                new_state = self.llm.with_structured_output(self.struct_type).invoke(msgs)
        except TimeoutError:
            print(f"Warning: generate_struct timed out after {self.timeout_seconds} seconds, keeping current state")
            return self.current_state
        except Exception as e:
            print(f"Error in generate_struct: {e}, keeping current state")
            return self.current_state
            
        # Compare old and new state values
        changes = []
        for field in self.struct_type.__annotations__:
            old_val = self.current_state.get(field)
            new_val = new_state.get(field)
            
            # Handle nested dictionaries by comparing their contents
            if isinstance(old_val, dict) and isinstance(new_val, dict):
                for subfield in old_val:
                    if old_val.get(subfield) != new_val.get(subfield):
                        changes.append(f"{field}.{subfield}")
            # Compare non-dict values directly
            elif old_val != new_val:
                changes.append(field)
                
        if changes and hasattr(self, 'on_change_callback'):
            self.on_change_callback(changes, new_state)

        self.current_state = new_state
        return self.current_state
    
    def on_change(self, callback: Callable[[List[str], Any], None]):
        self.on_change_callback = callback

    def state(self):
        return self.current_state
    
    def get_state_prompt(self) -> str:
        """Returns a human-readable description of the current state."""
        prompt = []
        for field, value in self.current_state.items():
            if isinstance(value, dict):
                nested_values = [f"{k}: {v}" for k, v in value.items()]
                prompt.append(f"{field}: {{{', '.join(nested_values)}}}")
            elif isinstance(value, list):
                prompt.append(f"{field}: [{', '.join(map(str, value))}]")
            else:
                prompt.append(f"{field}: {value}")
        return "\n".join(prompt)


j = json.loads("""{
  "name": "D&D Campaign State",
  "fields": [
    {
      "name": "campaignName",
      "type": "string",
      "description": "The name of the campaign.",
      "default": "",
      "required": true
    },
    {
      "name": "campaignSetting",
      "type": "string",
      "description": "A brief description of the campaign's setting.",
      "default": "",
      "required": false
    },
    {
      "name": "campaignSummary",
      "type": "string",
      "description": "A summary of the campaign's overall story and goals.",
      "default": "",
      "required": false
    },
    {
      "name": "currentSession",
      "type": "number",
      "description": "The current session number.",
      "default": "$SESSION_NUMBER$",
      "required": true
    },
    {
      "name": "currentLocation",
      "type": "string",
      "description": "The current location of the party.",
      "default": "",
      "required": false
    },
    {
      "name": "party",
      "type": "array",
      "description": "An array of the player characters in the party.",
      "default": "[]",
      "required": true
    },
    {
      "name": "npcs",
      "type": "object",
      "description": "A collection of non-player characters.",
      "default": "{}",
      "required": false
    },
    {
      "name": "factions",
      "type": "array",
      "description": "A list of factions involved in the campaign.",
      "default": "[]",
      "required": false
    },
    {
      "name": "majorEvents",
      "type": "array",
      "description": "A list of significant events that have occurred in the campaign.",
      "default": "[]",
      "required": false
    },
    {
      "name": "looseEnds",
      "type": "array",
      "description": "A list of unresolved plot threads or questions.",
      "default": "[]",
      "required": false
    },
    {
      "name": "secrets",
      "type": "object",
      "description": "A collection of secrets known to the party and/or the GM.",
      "default": "{}",
      "required": false
    },
    {
      "name": "notes",
      "type": "string",
      "description": "General notes about the state of the campaign.",
      "default": "",
      "required": false
    }
  ]
}""")


if __name__ == "__main__":
    from typing import Literal

    def print_changes(name, changes: List[str], new_state: Any):
        changed_state = {}
        for change in changes:
            if "." in change:  # Handle nested changes
                parent, child = change.split(".")
                if parent not in changed_state:
                    changed_state[parent] = {}
                changed_state[parent][child] = new_state[parent][child]
            else:
                changed_state[change] = new_state[change]

        for field, value in changed_state.items():
            if isinstance(value, dict):
                for subfield, subvalue in value.items():
                    print(f"{name:<30} {field}.{subfield:<26} {str(subvalue):<20}")
            else:
                print(f"{name:<30} {field:<30} {str(value):<20}")
    
    class GameProgress(TypedDict):
        enemies: List[str] # the names of the enemies in the current location, enemy names are at most 4 words.
        friends: List[str] # the names of the friendly characters in the current location, friend names are at most 4 words.
        location: str # the name of the current location
        time: str # in ISO 8601 format
    
    def print_changes_game_progress(changes: List[str], new_state: GameProgress):
        print_changes("GameProgress", changes, new_state)

    progressor = Structuralizer(GameProgress, "You are a note taker who tracks changes in the core mechanics of a dungeons and dragons game. You are an accurate and concise note taker. You only write things that the Dungeon Master or players have said or done. You don't make up things. When new things are introduced to the story, you add them, when things are no longer relevant, you remove them.")
    progressor.on_change(print_changes_game_progress)


    class EnvironmentConditions(TypedDict):
        current_weather: Literal["sunny", "cloudy", "rainy", "snowy", "windy", "foggy", "stormy"]
        current_temperature: float  # Fahrenheit
        current_humidity: float     # percent
        current_wind: float         # mph
        current_wind_direction: Literal["N", "NE", "E", "SE", "S", "SW", "W", "NW"]

    def print_changes_environment_conditions(changes: List[str], new_state: EnvironmentConditions):
        print_changes("EnvironmentConditions", changes, new_state)

    environmentor = Structuralizer(EnvironmentConditions, "You are a note taker who tracks changes in the narrative of a dungeons and dragons game. You are an accurate and concise note taker. You only write things that the Dungeon Master or players have said or done. You don't make up things. When new environmental things are introduced to the story, you add them, when environmental things are resolved, you remove them.")
    environmentor.on_change(print_changes_environment_conditions)

    class StoryThemes(TypedDict):
        topic: Literal["religion", "politics", "science", "technology", "history", "literature", "art", "music", "food", "travel", "sports", "entertainment", "other"]
        theme: Literal["heroism", "villainy", "love", "loss", "betrayal", "redemption", "sacrifice", "survival", "discovery", "adventure", "mystery", "horror", "comedy", "drama", "tragedy", "fantasy", "science fiction", "western", "noir", "romance", "tragedy", "comedy of errors", "tragedy of errors"]
        character_growth: Literal["physical", "mental", "emotional", "spiritual", "social", "cultural", "political", "economic", "environmental", "other"]


    def print_changes_story_themes(changes: List[str], new_state: StoryThemes):
        print_changes("StoryThemes", changes, new_state)

    story_themor = Structuralizer(StoryThemes, "You are a note taker who tracks thematic changes in a dungeons and dragons game. You are an accurate and concise note taker. You only write things that the Dungeon Master or players have said or done. You don't make up things. When new themes are introduced to the story, you add them, when themes are no longer relevant, you remove them.")
    story_themor.on_change(print_changes_story_themes)

    dm = ChatOpenAI(
        base_url="http://cluster:32605/v1",
        model="gemma3:4b",
        temperature=0.7,
        max_tokens=50,
        max_retries=3,
        request_timeout=1000,
    )
    messages = [
        SystemMessage(content="You are a dungeon master for a text adventure game. You invent the story as the player progresses through the game. You are also a master of the English language, and you are able to write in a way that is engaging and interesting to the player. You are a master storyteller. "),
    ]


    class DMResponse(TypedDict):
        response: str # a short 1-3 sentence description of the new events of the dungeon and dragons game

    try:
        with timeout_context(60):  # 60 seconds for initial description
            res = dm.with_structured_output(DMResponse).invoke(messages + [HumanMessage(content="Describe the initial premise of a brand new Dungeons and Dragons campaign. Include many elaborate details. Use 5 paragraphs.")])
    except TimeoutError:
        print("Warning: Initial description generation timed out, using fallback")
        res = {'response': 'A mysterious campaign begins in an ancient realm.'}
    except Exception as e:
        print(f"Error in initial description: {e}, using fallback")
        res = {'response': 'A mysterious campaign begins in an ancient realm.'}
        
    m = AIMessage(content=res['response'])
    messages.append(m)
    progressor.add_message(m)
    environmentor.add_message(m)
    story_themor.add_message(m)

    print("\n".join(res['response'].split(". ")))

    for i in range(15):
        print("="*100)
        try:
            with timeout_context(30):  # 30 seconds for each continuation
                res = dm.with_structured_output(DMResponse).invoke(messages + [HumanMessage(content="What happens next? Write 1 to 3 sentences.")])
        except TimeoutError:
            print("Warning: Continuation generation timed out, using fallback")
            res = {'response': 'The story continues...'}
        except Exception as e:
            print(f"Error in continuation: {e}, using fallback")
            res = {'response': 'The story continues...'}
            
        # print("\n".join(res['response'].split(". ")))
        # print()
        m = AIMessage(content=res['response'])
        messages.append(m)
        progressor.notice(m)
        environmentor.notice(m)
        story_themor.notice(m)

        print("="*100)
        # input()

    try:
        with timeout_context(60):  # 60 seconds for location description
            res = dm.with_structured_output(DMResponse).invoke(messages + [HumanMessage(content="The party has just entered a new location. Describe the new location and the events that take place.")])
    except TimeoutError:
        print("Warning: Location description generation timed out, using fallback")
        res = {'response': 'The party enters a new mysterious location.'}
    except Exception as e:
        print(f"Error in location description: {e}, using fallback")
        res = {'response': 'The party enters a new mysterious location.'}
        
    m = AIMessage(content=res['response'])
    messages.append(m)

    for i in range(15):
        print("="*100)
        try:
            with timeout_context(30):  # 30 seconds for each continuation
                res = dm.with_structured_output(DMResponse).invoke(messages + [HumanMessage(content="What happens next? Write 1 to 3 sentences.")])
        except TimeoutError:
            print("Warning: Continuation generation timed out, using fallback")
            res = {'response': 'The story continues...'}
        except Exception as e:
            print(f"Error in continuation: {e}, using fallback")
            res = {'response': 'The story continues...'}
            
        # print("\n".join(res['response'].split(". ")))
        # print()
        m = AIMessage(content=res['response'])
        messages.append(m)
        progressor.notice(m)
        environmentor.notice(m)
        story_themor.notice(m)

        print("="*100)
        # input()

    try:
        with timeout_context(60):  # 60 seconds for victory description
            res = dm.with_structured_output(DMResponse).invoke(messages + [HumanMessage(content="The party has just defeated a major enemy. Describe the events that take place. Write 1 to 3 sentences.")])
    except TimeoutError:
        print("Warning: Victory description generation timed out, using fallback")
        res = {'response': 'The party celebrates their victory.'}
    except Exception as e:
        print(f"Error in victory description: {e}, using fallback")
        res = {'response': 'The party celebrates their victory.'}
        
    m = AIMessage(content=res['response'])
    messages.append(m)
    
    for i in range(15):
        print("="*100)
        try:
            with timeout_context(30):  # 30 seconds for each continuation
                res = dm.with_structured_output(DMResponse).invoke(messages + [HumanMessage(content="What happens next? Write 1 to 3 sentences.")])
        except TimeoutError:
            print("Warning: Continuation generation timed out, using fallback")
            res = {'response': 'The story continues...'}
        except Exception as e:
            print(f"Error in continuation: {e}, using fallback")
            res = {'response': 'The story continues...'}
            
        # print("\n".join(res['response'].split(". ")))
        # print()
        m = AIMessage(content=res['response'])
        messages.append(m)
        print("progressor")
        progressor.notice(m)
        print("environmentor")
        environmentor.notice(m)
        print("story_themor")
        story_themor.notice(m)
        print("enemy count:", len(progressor.state()["enemies"]))

        print("="*100)
        # input()


    def print_changes(name, changes: List[str], new_state: Any):
        changed_state = {}
        for change in changes:
            if "." in change:  # Handle nested changes
                parent, child = change.split(".")
                if parent not in changed_state:
                    changed_state[parent] = {}
                changed_state[parent][child] = new_state[parent][child]
            else:
                changed_state[change] = new_state[change]

        for field, value in changed_state.items():
            if isinstance(value, dict):
                for subfield, subvalue in value.items():
                    print(f"{name:<30} {field}.{subfield:<26} {str(subvalue):<20}")
            else:
                print(f"{name:<30} {field:<30} {str(value):<20}")
    
    class FieldDef(TypedDict):
        name: str
        type: str
        description: str
        default: str
        required: bool

    class TypeDef(TypedDict):
        name: str
        fields: List[FieldDef]
    
    def generate_typed_dict(type_def: TypeDef) -> Type[TypedDict]:
        """Generates a TypedDict subclass based on a TypeDef instance."""
        annotations = {}
        for field_def in type_def['fields']:
            # Convert string type representation to actual type
            type_str = field_def['type'].strip()
            
            # Map JSON schema types to Python types
            if type_str == 'string':
                annotations[field_def['name']] = str
            elif type_str == 'number':
                annotations[field_def['name']] = float
            elif type_str == 'integer':
                annotations[field_def['name']] = int
            elif type_str == 'boolean':
                annotations[field_def['name']] = bool
            elif type_str == 'array':
                # For arrays, we'll use List[Any] as a default
                # In a more sophisticated version, we could parse the items type
                annotations[field_def['name']] = List[Any]
            elif type_str == 'object':
                # For objects, we'll use Dict[str, Any] as a default
                annotations[field_def['name']] = dict
            elif type_str.startswith('List['):
                # Handle List types with specific inner types
                inner_type = type_str[5:-1]  # Remove List[] wrapper
                if inner_type == 'string':
                    annotations[field_def['name']] = List[str]
                elif inner_type == 'number':
                    annotations[field_def['name']] = List[float]
                elif inner_type == 'integer':
                    annotations[field_def['name']] = List[int]
                elif inner_type == 'boolean':
                    annotations[field_def['name']] = List[bool]
                else:
                    annotations[field_def['name']] = List[Any]
            elif type_str.startswith('Literal['):
                # Handle Literal types - this is more complex and would need proper parsing
                # For now, we'll use str as a fallback
                annotations[field_def['name']] = str
            else:
                # Fallback to str for unknown types
                annotations[field_def['name']] = str

        # Create the TypedDict class dynamically
        # Pass annotations as keyword arguments to TypedDict
        typed_dict_class = TypedDict(type_def['name'], **annotations)
        
        # Add docstring
        typed_dict_class.__doc__ = '\n'.join(f"{field_def['name']}: {field_def['description']}"
                                           for field_def in type_def['fields'])

        return typed_dict_class

#     # llm = ChatOpenAI(
#     #     base_url="http://cluster:32605/v1",
#     #     model="gemma3:4b",
#     #     temperature=0.7,
#     #     max_tokens=50,
#     #     max_retries=3,
#     #     timeout=1000,
#     # )

#     # res = llm.with_structured_output(TypeDef).invoke([HumanMessage(content="Create a type definition to describe the state of a Dungeons and Dragons campaign. This will be used for note taking over many sessions.")])
# )

#     # messages = [
#     #     SystemMessage(content="You are a dungeon master for a text adventure game. You invent the story as the player progresses through the game. You are also a master of the English language, and you are able to write in a way that is engaging and interesting to the player. You are a master storyteller. "),
#     # ]


#     # class DMResponse(TypedDict):
#     #     response: str # a short 1-3 sentence description of the new events of the dungeon and dragons game

#     # res = dm.with_structured_output(DMResponse).invoke(messages + [HumanMessage(content="Describe the initial premise of a brand new Dungeons and Dragons campaign. Include many elaborate details. Use 5 paragraphs.")])
#     # m = AIMessage(content=res['response'])
#     # messages.append(m)
#     # progressor.add_message(m)
#     # environmentor.add_message(m)
#     # story_themor.add_message(m)

#     # print("\n".join(res['response'].split(". ")))

#     # for i in range(10):
#     #     print("="*100)
#     #     res = dm.with_structured_output(DMResponse).invoke(messages + [HumanMessage(content="What happens next? Write 1 to 3 sentences.")])
#     #     print("\n".join(res['response'].split(". ")))
#     #     print()
#     #     m = AIMessage(content=res['response'])
#     #     messages.append(m)
#     #     progressor.notice(m)
#     #     environmentor.notice(m)
#     #     story_themor.notice(m)

#     #     input()



    # res = j
    # print(json.dumps(res, indent=2))
    # DnDDesc = generate_typed_dict(res)
    # # Print the DnDDesc class details
    # print("\nDungeons & Dragons Campaign State Type Definition:")
    # print("=" * 50)
    # print("\nFields:")
    # for field_name, field_type in DnDDesc.__annotations__.items():
    #     print(f"\n{field_name}:")
    #     print(f"  Type: {field_type}")
        
    #     # Get the field description from the docstring
    #     field_desc = next((line.split(': ')[1] for line in DnDDesc.__doc__.split('\n') 
    #                       if line.startswith(f"{field_name}:")), "No description")
    #     print(f"  Description: {field_desc}")
        
    #     # Get default value if it exists
    #     if hasattr(DnDDesc, field_name):
    #         print(f"  Default: {getattr(DnDDesc, field_name)}")
    
    # import pdb; pdb.set_trace(